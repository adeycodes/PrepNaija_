import { OfflineQuestion, Question } from "@/types";
import { CACHE_CONFIG } from "@/utils/constants";

class QuestionService {
  private dbName = "PrepNaijaDB";
  private version = 1;
  private db: IDBDatabase | null = null;

  async initDB(): Promise<void> {
    if (this.db) return;

    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        
        if (!db.objectStoreNames.contains("questions")) {
          const questionStore = db.createObjectStore("questions", { keyPath: "id" });
          questionStore.createIndex("subject", "subject", { unique: false });
          questionStore.createIndex("cached", "cached", { unique: false });
        }
      };
    });
  }

  async cacheQuestions(subject: string, examType: string = 'JAMB'): Promise<void> {
    try {
      const headers: HeadersInit = {
        'Content-Type': 'application/json'
      };
      
      const response = await fetch(`/api/questions/random/${subject}/${CACHE_CONFIG.questionsPerSubject}?examType=${examType}`, {
        headers,
        credentials: "include"
      });

      if (!response.ok) {
        throw new Error(`Failed to fetch questions: ${response.statusText}`);
      }

      const questions: Question[] = await response.json();
      await this.initDB();

      if (!this.db) throw new Error("Failed to initialize database");

      const transaction = this.db.transaction(["questions"], "readwrite");
      const store = transaction.objectStore("questions");

      const cachedQuestions: OfflineQuestion[] = questions.map(q => ({
        ...q,
        cached: true,
        cacheDate: new Date(),
        examType: examType // Ensure exam type is stored
      }));

      for (const question of cachedQuestions) {
        await new Promise<void>((resolve, reject) => {
          const request = store.put(question);
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      }

      console.log(`‚úÖ Cached ${questions.length} ${subject} (${examType}) questions for offline use`);
    } catch (error) {
      console.error("‚ùå Failed to cache questions:", error);
      throw error;
    }
  }

  async getCachedQuestions(subject: string, count: number = 20, examType?: string): Promise<OfflineQuestion[]> {
    await this.initDB();
    
    if (!this.db) throw new Error("Failed to initialize database");

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(["questions"], "readonly");
      const store = transaction.objectStore("questions");
      const index = store.index("subject");
      const request = index.getAll(subject);

      request.onsuccess = () => {
        let questions = request.result as OfflineQuestion[];
        
        // Filter by exam type if specified
        if (examType) {
          questions = questions.filter(q => q.examType === examType);
        }
        
        // Filter out expired cached questions
        const validQuestions = questions.filter(q => {
          const age = Date.now() - new Date(q.cacheDate).getTime();
          return age < CACHE_CONFIG.maxCacheAge;
        });

        // Shuffle and return requested count
        const shuffled = validQuestions.sort(() => Math.random() - 0.5);
        console.log(`üì± Serving ${shuffled.slice(0, count).length} cached ${subject} questions (offline)`);
        resolve(shuffled.slice(0, count));
      };

      request.onerror = () => reject(request.error);
    });
  }

  async clearExpiredCache(): Promise<void> {
    await this.initDB();
    
    if (!this.db) return;

    const transaction = this.db.transaction(["questions"], "readwrite");
    const store = transaction.objectStore("questions");
    const request = store.getAll();

    request.onsuccess = () => {
      const questions = request.result as OfflineQuestion[];
      const now = Date.now();

      questions.forEach(q => {
        const age = now - new Date(q.cacheDate).getTime();
        if (age >= CACHE_CONFIG.maxCacheAge) {
          store.delete(q.id);
        }
      });
    };
  }

  async getCacheStats(): Promise<{ [subject: string]: number }> {
    await this.initDB();
    
    if (!this.db) return {};

    return new Promise((resolve) => {
      const transaction = this.db!.transaction(["questions"], "readonly");
      const store = transaction.objectStore("questions");
      const request = store.getAll();

      request.onsuccess = () => {
        const questions = request.result as OfflineQuestion[];
        const stats: { [subject: string]: number } = {};

        questions.forEach(q => {
          const age = Date.now() - new Date(q.cacheDate).getTime();
          if (age < CACHE_CONFIG.maxCacheAge) {
            stats[q.subject] = (stats[q.subject] || 0) + 1;
          }
        });

        resolve(stats);
      };

      request.onerror = () => resolve({});
    });
  }

  isOnline(): boolean {
    return navigator.onLine;
  }

  async getQuestions(subject: string, count: number = 20, examType: string = 'JAMB'): Promise<Question[]> {
    if (this.isOnline()) {
      try {
        console.log(`üåê Fetching ${count} ${subject} (${examType}) questions online...`);
        
        const headers: HeadersInit = {
          'Content-Type': 'application/json'
        };
        
        const response = await fetch(`/api/questions/random/${subject}/${count}?examType=${examType}`, {
          headers,
          credentials: "include"
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const questions = await response.json();
        
        // Cache questions for offline use
        try {
          await this.cacheQuestions(subject, examType);
        } catch (cacheError) {
          console.warn("Failed to cache questions:", cacheError);
        }
        
        console.log(`‚úÖ Served ${questions.length} ${subject} (${examType}) questions online`);
        return questions;
      } catch (error) {
        // If online fetch fails, try cached questions
        console.warn(`‚ö†Ô∏è Online fetch failed, using cached questions:`, error);
        return await this.getCachedQuestions(subject, count, examType);
      }
    } else {
      console.log(`üì± Device offline, using cached questions`);
      return await this.getCachedQuestions(subject, count, examType);
    }
  }
}

export const questionService = new QuestionService();
